# 平时作业1-简单图形绘制 作业报告  



[TOC]

## 具体工作

1. **环境搭建**：
   - 使用GLFW和GLAD搭建OpenGL开发环境。
   - 初始化ImGui用于图形用户界面。
2. **黑板及其边框绘制**：
   - 在场景中相机正面的墙面上绘制一个黑板。
   - 调整墙面的位置和大小，使场景比例协调。
3. **风车绘制与交互**：
   - 实现快捷键F绘制风车，C键改变风车颜色，S键控制风车旋转。
4. **萤火虫绘制与交互**：
   - 实现场景中随机生成一定数量的萤火虫，并且可以朝向各个方向飞行。
   - 外观具有物理仿真效果
5. **碰撞绘制与交互**：
   - 实现一个简易的小球绘制，且可以通过imgui面板调整其颜色。
   - 小球能够在场景中朝各个方向运动，当与墙面发生碰撞时运动方向会相应地改变。

## 技术方案

### 1. 环境搭建

- **GLFW和GLAD**：用于创建OpenGL上下文和加载OpenGL函数。
- **ImGui**：用于创建用户界面，方便调试和交互。

### 2. 黑板绘制

- **顶点生成**：使用数学公式计算黑板的顶点位置、法线和纹理坐标。

  > 将黑板的宽、高以及深度分别÷2，在坐标系中按照立方体一贯的标准（参考给出的Cornell box中立方体的代码）填入即可得到
  >
  > (-width / 2, -height / 2,  depth / 2)
  >
  > (width / 2, -height / 2,  depth / 2)
  >
  > ...
  >
  > 然后是黑板的空间坐标位置，根据box的坐标`cubePos`以及边长计算得到黑板的XYZ
  >
  > 例如Z=cubePos.z-边长/2+黑板厚度/2（Z轴朝向相机）
  >
  > 最后`model`矩阵使用`glm::scale`缩放到自己原本的大小

- **纹理映射**：通过`stb_image`库加载黑板纹理，并应用到黑板表面。

  > 读取纹理图片到纹理缓冲区
  >
  > 设置纹理环绕方式为`GL_REPEAT`让纹理完全填充黑板区域
  >
  > 设置过滤方式为线性插值使得图像在放大缩小时有更好的显示效果
  >
  > 生成`mipmap`使得图像在远处显示时使用分辨率更小的图像显示节约程序的开销
  >
  > 在`fragment.glsl`中定义2个`sample2D`的纹理采样，根据渲染循环中对`uniform`变量的传入选择渲染不同的纹理传入片段着色器
### 3. 黑板边框绘制

- **顶点生成**：使用数学公式计算黑板的顶点位置、法线和纹理坐标。

  > 让边框紧贴黑板
  >
  > 厚度略大于黑板

- **纹理映射**：通过`stb_image`库加载木板纹理，并应用到黑板表面。

  > 使用木质纹理

### 4. 风车绘制与交互

- **风车顶点数据**：预定义风车的顶点数据，使用OpenGL绘制。

  > 手动输入风车8个三角形的坐标
  >
  > 使用`GL_LINE_LOOP`绘制三角形线框

- **颜色填充**：通过ImGui界面选择风车颜色，使用随机数生成器实现颜色变化。

  > 使用`GL_TRIANGLES`绘制带颜色三角形
  >
  > 使用`GL_LINE_LOOP`绘制三角形线框

- **旋转效果**：使用矩阵变换公式实现风车的旋转，旋转角度与时间和速度相关。

  > 使用`glm::rotate`方法对`model`矩阵绕Z轴进行一定角度的旋转
  >
  > 使用`deltaTime`帧间时间确保旋转在不同设备上呈现效果相同

### 5. 萤火虫绘制

- **点数据**

  > 使用随机数创建在`cubePos`各方向[-0.5, 0.5]的坐标

- **飞行运动**

  > 使用随机数比较大小来增加/减少X轴/Y轴坐标，控制向左/右以及上/下飞行

- **萤火虫绘制**

  > 启用`GL_PROGRAM_POINT_SIZE`控制的点大小，对片段着色器进行修改以实现圆形效果。
  >
  > 将 `gl_PointSize` 设置为所需的点大小
  >
  > 在片段着色器中，通过计算片段相对于圆心的距离，决定是否丢弃片段，从而实现圆形点。
  >
  > 先绘制一个黑色小圆表示萤火虫身体，再绘制2个黄色的大圆，其中最外层的颜色更淡一点，同时启用混合`glEnable(GL_BLEND)`，使用`glBlendFunc`设置混合方程增加`alpha`通道，绘制出来类似光晕，达到物理仿真的效果

- **根据相机距离调整萤火虫大小**

  > 在顶点着色器中：
  >
  > **视图空间转换**：`view * model * vec4(aPos, 1.0)`将顶点从模型空间转换到视图空间。
  >
  > **计算距离**：使用`length(viewPos)`计算从相机到当前点的距离。
  >
  > **动态调整点大小**：`gl_PointSize`根据距离动态调整。

### 6. 碰撞小球绘制

- **球体绘制**

  > 使用**细分三角面**来生成球体的顶点数据
  >
  > **生成球体顶点数据**：
  >
  > 通过参数化的方式生成球体的顶点。球体的每个点可以通过以下公式计算：
  >
  > - `x = radius * sin(theta) * cos(phi)`
  > - `y = radius * cos(theta)`
  > - `z = radius * sin(theta) * sin(phi)`
  >
  > 其中：
  >
  > - `theta` 是垂直方向的角度（从顶部到底部）。
  > - `phi` 是水平方向的角度（绕着垂直轴旋转）。
  > 
  > `GL_TRIANGLE_STRIP`渲染球体：通过为球体建立网格的方式来生成顶点数据，并使用 `glDrawArrays` 来绘制球体

- **球体运动**

  > 每帧都根据`deltaTime`来更新小球的位置, 将小球XYZ各个分量上的坐标加上速度*`deltaTime`使得小球在不同设备上具有相同的移动速度，并且可以在三维空间中向各个方向移动

- **碰撞检测**

  > 场景有6个面：天花板、地板、左、右、前、后面（后面未被绘制）。我们需要检测小球是否与这些面碰撞，并在碰撞时反转速度方向。
  >
  > 当检测到小球的中心点加/减小球半径大于/小于场景某个面的位置，将小球速度对应的某个轴的分量变为其相反数

### 7. 场景调整

- **相机位置**：通过调整相机位置和视角，使黑板在场景中显得更大。

  > 绑定↑↓←→键到`camera`类，使得在按键时能调整相机在坐标系中的位置，加上/减去相应的偏移量

- **墙面位置**：通过数学计算调整墙面的位置和大小，确保场景比例协调。

  > 修改立方体的坐标，手动增加宽度
  >
  > 将立方体`vertices`中的坐标的X坐标全部乘以`scale`，即可得到宽度为原来`scale`倍的box场景
  >
  > 例如(-0.5f * scale, -0.5f, -0.5f)

## 程序使用说明

- **快捷键操作**：
  
  - `↑↓←→`键：平移相机
  - `F`键：在黑板上绘制风车。
  - `C`键：改变风车的颜色填充。
  - `S`键：控制风车的旋转。
  - `L`键：锁定或解锁鼠标光标。
  - `esc`键：退出程序
  
- **鼠标操作（锁定时不可用）**：
  - 鼠标移动：控制相机视角。
  
  - 鼠标滚轮：缩放视角。
  
- **`imgui`面板**：
  - 显示程序帧刷新率
  - 锁定鼠标按钮
  - 绘制碰撞球体/萤火虫
  - 更换/显示颜色：
    - 风车
    - 背景
    - 各个墙面
    - 灯光
    - 碰撞球体

## 程序运行截图

![SimpleScene](SimpleScene.png)
